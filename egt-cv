#!/usr/bin/python3
from __future__ import annotations
from typing import List, Dict, Optional, Set
import argparse
import configparser
import datetime
import logging
import os
import shutil
import subprocess
import sys

import jinja2
import yaml

import egtlib
from egtlib import cli


VERSION = "0.1"


class ProjectGroup:
    def __init__(self, name):
        self.name: str = name
        self.entries = []
        self.sources: Set[str] = set()

    def add(self, project):
        """
        Add a project to this group
        """
        self.entries.append(project)
        self.sources.add(project.abspath)

    def _project_sort_key(self, p):
        """
        Get the sort key to use to sort projects before merging
        """
        since, until = p.formal_period
        return (
            not p.archived,
            until or since or datetime.date.today(),
            p.name,
        )

    def get_merged_info(self):
        """
        Merge all project info in a single CV entry
        """
        # Sort with the most relevant last
        self.entries.sort(key=self._project_sort_key)

        # Defaults
        info = {
            "title": self.name.capitalize(),
            "group-title": None,
            "description": None,
            "homepage": None,
            "issuer": None,
            "tags": frozenset(),
        }
        all_archived = True
        period_since = None
        period_until = None

        for p in self.entries:
            # Get the various text fields, keeping the latest one
            for field in ("group-title", "title", "recipient", "description", "homepage", "issuer"):
                val = p.meta.get(field, None)
                if val is not None:
                    info[field] = val

            # Keep only the tags of the last one
            info["tags"] = p.tags

            # Get the period
            since, until = p.formal_period

            # Check if there are still active projects in this group
            if not p.archived:
                all_archived = False
                if since or until:
                    period_until = until

            # Extend period ranges using since and until
            if period_since is None:
                period_since = since
            elif since is not None and since < period_since:
                period_since = since
            if period_until is None:
                period_until = until
            elif until is not None and until > period_until:
                period_until = until

        # Group-title, if present, overrides title
        val = info.pop("group-title", None)
        if val is not None:
            info["title"] = val

        # If there are still active projects, unset 'until' to say that the
        # entry is still ongoing
        if not all_archived:
            if period_until is not None:  # and period_until >= datetime.date.today():
                period_until = None

        # Set the final period information
        info["period"] = {
            "since": period_since,
            "until": period_until,
        }

        return info


class Employer:
    def __init__(self, name: str):
        self.name = name
        self.job_types: List[str] = []
        self.since = None
        self.until = None
        self.current = False
        self.sources: Set[str] = set()

    def extend(self, since: Optional[datetime.datetime], until: Optional[datetime.datetime]):
        if self.since is None or (since is not None and since < self.since):
            self.since = since

        if self.until is None or (until is not None and until > self.until):
            self.until = until
        if until is None:
            self.current = True

    def translatable_strings(self):
        yield self.name
        yield from self.job_types

    def sort_key(self):
        if self.current:
            return datetime.date(9999, 12, 31)
        else:
            if self.until is None:
                raise RuntimeError(f"Employer {self.name} (from {self.sources!r}) has no until date")
            return self.until


class CV:
    LANG_SKILLS = {
        "A1": "beginner",
        "A2": "elementary",
        "B1": "intermediate",
        "B2": "upper intermediate",
        "C1": "advanced",
        "C2": "master",
    }

    def __init__(self, dirname):
        self.dirname = dirname
        self.personal = {}
        self.shortbio = []
        self.languages = {}
        self.technical_skills = []
        self.social_skills = []
        self.tags = {}
        self.job_types = {}
        self.job_employers: Dict[str, Employer] = {}
        self.logs = {}
        self.egt_blacklist = set()

    def load(self):
        # Load base info from yaml files
        for fn in sorted(os.listdir(self.dirname)):
            if not fn.endswith(".yaml"):
                continue
            pathname = os.path.join(self.dirname, fn)
            with open(pathname) as fd:
                info = yaml.load(fd)
                self.acquire_structured(info)

        # Load historical info from egt, based on tags set in yaml files
        for k, v in self.tags.items():
            if isinstance(v, str):
                tags = frozenset((v,))
            else:
                tags = frozenset(v)
            self.acquire_egt(k, tags)

    def acquire_structured(self, info):
        """
        Acquire general info from a data structure
        """
        i = info.get("personal", None)
        if i is not None:
            for k, v in i.items():
                if k == "telephone":
                    tels = self.personal.setdefault(k, [])
                    for t in v:
                        for tk, tv in t.items():
                            tels.append({
                                "name": tk,
                                "value": tv,
                            })
                elif k in ("email", "homepage"):
                    # Coerce to list
                    if isinstance(v, str):
                        self.personal[k] = [v]
                    else:
                        self.personal[k] = v
                else:
                    self.personal[k] = v

        i = info.get("shortbio", None)
        if i is not None:
            if isinstance(i, str):
                self.shortbio.append(i)
            else:
                self.shortbio.extend(i)

        i = info.get("languages", None)
        if i is not None:
            for name, level in i.items():
                if level == "main":
                    self.languages[name] = "mother tongue"
                else:
                    level = level.upper()
                    self.languages[name] = f"{level} ({self.LANG_SKILLS[level]})"

        i = info.get("technical_skills", None)
        if i is not None:
            if isinstance(i, str):
                self.technical_skills.append(i)
            else:
                self.technical_skills.extend(i)

        i = info.get("social_skills", None)
        if i is not None:
            if isinstance(i, str):
                self.social_skills.append(i)
            else:
                self.social_skills.extend(i)

        i = info.get("tags", {})
        for k, v in i.items():
            self.tags[k] = v

        i = info.get("job-types", {})
        for k, v in i.items():
            self.job_types[k] = v

        i = info.get("job-employers", {})
        for k, v in i.items():
            self.job_employers[k] = Employer(v)

        i = info.get("egt-blacklist", [])
        if isinstance(i, str):
            self.egt_blacklist.add(i)
        else:
            self.egt_blacklist.update(i)

    def acquire_egt(self, log_group, tags):
        """
        Acquire historical info from egt projects with the given tags
        """
        config = configparser.ConfigParser()
        config.read([os.path.expanduser("~/.egt.conf")])
        egt = egtlib.Egt(config=config, filter=tags, show_archived=True)

        # Collect egt entries and group them by group name
        groups = {}
        for p in egt.projects:
            if p.name in self.egt_blacklist:
                continue
            group = groups.get(p.group, None)
            if group is None:
                group = ProjectGroup(p.group)
                groups[p.group] = group
            group.add(p)

        # Get the merged group info
        logs = []
        for g in groups.values():
            info = g.get_merged_info()
            for k, v in self.job_types.items():
                if k in info["tags"]:
                    info["job_type"] = v
            for k, v in self.job_employers.items():
                if k in info["tags"]:
                    info["employer"] = v
                    v.sources.update(g.sources)
            if log_group == "work" and not info.get("employer"):
                continue
            logs.append(info)

        if logs:
            logs.sort(key=lambda x: (
                    x["period"]["until"] or datetime.date.today(),
                    x["period"]["since"] or datetime.date.today()
                ), reverse=True)
            self.logs.setdefault(log_group, []).extend(logs)

            for log_entry in logs:
                if "employer" not in log_entry:
                    continue
                employer = log_entry["employer"]
                employer.extend(log_entry["period"]["since"], log_entry["period"]["until"])
                if "job_type" in log_entry:
                    if log_entry["job_type"] not in employer.job_types:
                        employer.job_types.append(log_entry["job_type"])

    def template_context(self):
        """
        Return a dict with all the arguments to pass to the template renderer
        """
        return {
            "dirname": self.dirname,
            "personal": self.personal,
            "shortbio": self.shortbio,
            "languages": self.languages,
            "technical_skills": self.technical_skills,
            "social_skills": self.social_skills,
            "lastedit": datetime.date.today(),
            "logs": self.logs,
            "employers": sorted(
                (e for e in self.job_employers.values() if e.sources),
                key=lambda x: x.sort_key(), reverse=True),
        }

    def dump(self, out=sys.stdout):
        """
        Dump all info we have to the given file descriptor
        """
        yaml.dump(self.template_context(), out)

    def translatable_strings(self):
        """
        Generate all the translatable strings found in the data
        """
        for k in ("nationality", "notes"):
            s = self.personal.get(k, None)
            if s is not None:
                yield s

        tel = self.personal.get("telephone", None)
        if tel is not None:
            for t in tel:
                yield t["name"]

        for s in self.shortbio:
            yield s

        yield from self.languages.get("mothertongue", [])

        for lang in self.languages.get("table", []):
            yield lang["name"]

        yield from self.technical_skills
        yield from self.social_skills
        yield from self.job_types.values()
        for e in self.job_employers.values():
            yield from e.translatable_strings()

        for name, entries in self.logs.items():
            for e in entries:
                for field in ("title", "description", "issuer"):
                    if e.get(field):
                        yield e[field]

    def extract_strings(self):
        """
        Extract translatable strings.

        Returns two Catalog objects: one for egt-cv and jinja2 templates, the
        other for personal CV information. The idea is that the translations of
        the first catalog can be public and shipped with egt-cv itself
        """
        from babel.messages import Catalog

        # Instantiate jinja2 machinery to get string extraction
        jinja_env = jinja2.Environment(extensions=['jinja2.ext.i18n'])

        # Build the egt-cv catalog
        c_tpl = Catalog()

        # Add strings from our consts
        for s in self.LANG_SKILLS.values():
            c_tpl.add(s)

        # Add strings from jinja2 templates
        tpldir = os.path.join(self.dirname, "templates")
        for fn in os.listdir(tpldir):
            if not fn.endswith(".html"):
                continue
            pathname = os.path.join(tpldir, fn)
            with open(pathname, "rt") as fd:
                for lineno, func, msg in jinja_env.extract_translations(fd.read()):
                    c_tpl.add(msg, locations=((pathname, lineno),))

        # Build the personal cv catalog
        c_cv = Catalog()

        # Add our strings
        for s in self.translatable_strings():
            c_cv.add(s)

        return c_tpl, c_cv

    def list_languages(self):
        """
        Get the list of available output languages
        """
        localedir = os.path.join(self.dirname, "locale")
        for lang in os.listdir(localedir):
            if lang[0] == ".":
                continue
            dn = os.path.join(localedir, lang)
            if not os.path.isdir(dn):
                continue
            yield lang, dn

    def update_catalog(self, msgfile, catalog):
        from babel.messages.pofile import read_po, write_po

        # Read the existing potfile if it exists
        if os.path.isfile(msgfile):
            with open(msgfile) as fd:
                cat = read_po(fd)
                cat.update(catalog)
        else:
            cat = catalog

        # Write updated catalogs
        with open(msgfile, "wb") as fd:
            write_po(fd, cat)

    def update_catalogs(self):
        """
        Update all available translation catalogs
        """
        c_tpl, c_cv = self.extract_strings()

        # Scan locale dirs
        for lang, langdir in self.list_languages():
            # If a locale dir exists, make sure it contains what is needed
            msgdir = os.path.join(langdir, "LC_MESSAGES")
            if not os.path.isdir(msgdir):
                os.mkdir(msgdir)
            self.update_catalog(os.path.join(msgdir, "egt-cv.po"), c_tpl)
            self.update_catalog(os.path.join(msgdir, "cv.po"), c_cv)
            # Let the user know what we did
            print(lang)

    def render(self, outdir, locales):
        """
        Render the curriculum, writing results to the given output directory
        """
        from babel.support import Translations
        # Reset the output directory
        if os.path.exists(outdir):
            shutil.rmtree(outdir)
        os.mkdir(outdir)

        # Get translations
        translations = Translations.load(
            os.path.join(self.dirname, "locale"),
            locales,
            "cv")

        # Instantiate jinja2 template machinery
        tpldir = os.path.join(self.dirname, "templates")
        jinja_env = jinja2.Environment(
            loader=jinja2.FileSystemLoader(tpldir),
            extensions=['jinja2.ext.i18n'])
        jinja_env.install_gettext_translations(translations, True)

        jinja_context = self.template_context()

        # Copy everything except .html files
        for fn in os.listdir(tpldir):
            if fn.startswith("."):
                continue
            if fn.endswith(".html"):
                # Render .html files with jinja2
                tpl = jinja_env.get_template(fn)
                rendered = tpl.render(**jinja_context)
                with open(os.path.join(outdir, fn), "wt") as fd:
                    fd.write(rendered)
            else:
                # Copy all other files
                shutil.copyfile(os.path.join(tpldir, fn), os.path.join(outdir, fn))

    def render_all_languages(self):
        """
        Render the curriculum for all languages
        """
        for lang, langdir in self.list_languages():
            merged_fname = os.path.join(langdir, "LC_MESSAGES/merged.po")
            compiled_fname = os.path.join(langdir, "LC_MESSAGES/cv.mo")

            # Merge all translations
            subprocess.check_call([
                "msgcat",
                os.path.join(langdir, "LC_MESSAGES/egt-cv.po"),
                os.path.join(langdir, "LC_MESSAGES/cv.po"),
                "-o", merged_fname])

            # Compile the merged translations
            subprocess.check_call(["msgfmt", "-c", "-f", "-o", compiled_fname, merged_fname])

            outdir = os.path.join(self.dirname, "cv-" + lang)
            self.render(outdir, (lang,))

            # Cleanup the compiled translations
            os.unlink(merged_fname)
            os.unlink(compiled_fname)


class CVCommand(cli.Command):
    @classmethod
    def add_subparser(cls, subparsers):
        parser = super().add_subparser(subparsers)
        parser.add_argument("project", help="project directory")
        return parser

    def get_cv(self):
        cv = CV(self.args.project)
        cv.load()
        return cv


class Dump(CVCommand):
    """
    Dump all cv information to standard output
    """

    def main(self):
        self.get_cv().dump()


class UpdateCatalog(CVCommand):
    """
    Update the catalogs of translatable strings.

    In order to start a translation, just run:
      mkdir $cvdir/locale/$LANG
    """

    NAME = "update_catalog"

    def main(self):
        self.get_cv().update_catalogs()


class Render(CVCommand):
    """
    Render the CV for all configured languages
    """
    def main(self):
        self.get_cv().render_all_languages()


def main():
    parser = argparse.ArgumentParser(description="Enrico's getting CVs done")
    parser.add_argument("--version", action="version", version="%(prog)s " + VERSION)
    parser.add_argument("--verbose", "-v", action="store_true", help="verbose output")
    parser.add_argument("--debug", action="store_true", help="debug output")
    # parser.add_argument("--archived", action="store_true", help="also show archived projects")
    subparsers = parser.add_subparsers(help="subcommands", required=True, dest="command")

    Dump.add_subparser(subparsers)
    UpdateCatalog.add_subparser(subparsers)
    Render.add_subparser(subparsers)

    args = parser.parse_args()
    cmd = args.command(args)

    try:
        return cmd.main()
    except cli.Fail as e:
        print(e, file=sys.stderr)
        return 1


if __name__ == '__main__':
    sys.exit(main())
